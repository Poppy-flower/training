一、栈：

1、后缀表达式的求值；
2、中缀到后缀表达式的转换；
3、深度优先搜索的非递归实现；
4、动态规划的优化：用于维护一个凸序列，便于二分查找，如LIS问题的O(nlgn)算法。

二、队列：
1、树的层序遍历；
2、广度优先搜索；
3、Bellman-Ford算法的SPFA实现；
4、网络流中FF算法的Edmonds-Karp实现，以及Preflow算法的队列优化实现。


三、二叉搜索树：

1、对大量的关键字的索引查找；
2、有很多平衡策略以改善其平均性能：
常用平衡树：AVL，红黑树，随机化BST，Splay Tree，Treap（或叫笛卡儿树）。

四、散列表（hash表）：
1、一般针对值域较大但状态很稀疏的应用，比如状态压缩记忆化搜索；
2、实现映射功能。

五、检索树（Trie）：
1、一般用于字符串索引算法，速度快，但占用空间较大（相对hash）；
2、常用的改进结构：Patricia线索树，多叉检索树（TST）。

六、优先队列：

1、常用的是二叉堆的实现，具体应用如堆排序和Dijkstra算法；
2、当需要快速合并两个优先队列时，常用二项式队列，实现简单。
3、注意最大最小堆的配对使用。

七、线段树和树状数组：

1、两者都可以用于离散对象的统计；
2、后者的步进函数的性质和应用值得注意；
3、前者基本上适用于任何的区间操作，如求区间最值，改变区间的值等。
4、线段树还可以用于优化状态的枚举，经常和动态规划结合。

八、后缀树与后缀数组：

1、总体规律是两者的实现都比较复杂，前者更甚，但是前者的功能也更强大；
2、几乎可以解决所有常见的关于字符串的算法，如最长回文子串，最长重复子串，以及很多的模式匹配问题。

九、并查集：

1、解决无向图的连通性问题，如用于Kruskal算法；
2、解决等价关系的查询（这是它的主要用武之地），如05年Baidu之星初赛的石头剪子布游戏；
3、优点是实现异常简单，缺点是合并后无法分离，若需要可以选择用动态树。

十、邻接表和边表：

1、表示图的最直接的方法；
2、后者更省空间，并且在一定程度上更好用，比如Bellman-Ford算法。 




栈和队列的区别?

栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。

队列先进先出，栈先进后出。

栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除

栈和堆的区别？

栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。

堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。

堆（数据结构）：堆可以被看成是一棵树，如：堆排序；

栈（数据结构）：一种先进后出的数据结构。
