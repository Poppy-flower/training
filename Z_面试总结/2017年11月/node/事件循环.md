事件循环机制
Node.js的事件循环是靠一个单线程不断地查询队列中是否有事件，当读取到事件时，将调用与这个事件关联的回调函数。上面介绍的事件驱动编程是事件循环的具体表现形式，如：在前面创建Web服务器中，回调函数是一个I/O操作；Node.js会监听3000端口是否有HTTP连接，当收到连接时会启动这个I/O操作，但不会等待操作的完成而是继续查看是否有下一个事件，如果有则继续依次处理。
Node.js的事件循环机制由以下几部分组成：
事件生产者：Node.js通过EventEmitter模块发送事件，发送的事件会被放到事件队列中。
事件队列：事件队列（Event Queue）是一个FIFO模型，一端用于接收推入的事件，另外一端拉出要处理的事件。
事件循环：事件循环（Event Loop）是Node.js事件机制的关键点，它一个单线程运行的任务，会不断轮询事件队列，并将轮询到的事件放到线程池中进行处理。
线程池：线程池（Thread Pool）是真正执行事件和任务处理的位置，比较耗时的操作如：网络I/O、文件操作I/O及其它会引起阻塞的操作都会在这里处理。处理完成后，会调用事件对应的回调函数。

结合上图及前面介绍可以认为，Node.js单线程运行最直接的体现，是指其在事件循环的时候是单线程运行的。在事件循环的时候，Node线程会把当前事件的读出，并将其放入到线程池处理，然后开始下一事件处理。
在Node的底层有一个libuv库，它实现了事件循环和线程池等功能。线程池是系统级别任务处理，也就是说事件的实际处理里是在更底层系统级完成的，在这一过程中并不是单线程的。处理完成后，线程池会调用与之绑定的回调函数，这样处理结果又被传回到了Node中。