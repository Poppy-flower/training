关于mvc

这里不详细讲解何为MVC模式，只是简单介绍，关于mvc的具体信息可以去网络上找寻，mvc模式在我理解来它将一个项目分解成三部分，分别是Model（模型），View（视图），Controller（控制器），这三个单词的缩写组合即为MVC.MVC是一种普遍的软件敏捷开发模式，在许多领域特别是桌面编程领域早已经得到了广泛的应用，然而在像php一样的脚本语言中比较难以实现，特别是几年前在脚本语言中很难看到mvc的实现，但是今年随着众多框架的涌现，mvc在各个框架中得到了初步实现，其他框架中的实现方式暂且不提，这里只是介绍codeigniter是如何实现mvc的。

关于单一入口

单一入口指在一个网站（应用程序）中，所有的请求都是指向一个脚本文件的，例如CI中的http：\\localhost\index.php，所有对应用程序的访问都是必须通过这个入口，正是单一入口才使得mvc模式得以实现，因为当你访问index.php的时候，应用程序会做大量的初始化工作，调用大量的基础类库，并根据index.php后面的参数加载控制器，然后加载试图，模型等内容信息。

ci的所有文件加载都要经过控制器调用，因为控制器是CI中的超类，也就是其他的类都依附于它，所以用单一入口方式访问CI应用程序的时候，需要在index.php的后面加上控制器名和控制器中的方法名，如果你对于此没有任何概念或者无法理解，可以去CI的官方网站下载它的官方文档，然后详细了解它的工作方式

CI的官方文档非常详尽易懂，这里描述的是文档上所不存在的基本原理部分。

 
 

或许应该先讲解CI的控制器是如何工作的，CI中的一个控制器就是用户编写的一个类，它继承自系统的Controller类，例如假设我们要构建一个可以通过http：\\localhost\index.php\control\func\param1\param2访问的页面，我们需要做哪些工作呢，首先我们要在system\application\controllers\文件夹下新建一个文件contro.php文件，这个文件即是我们要访问的控制器类所在文件，在此文件中创建以下内容：

详解PHP框架codeigniter(简称CI)如何实现MVC模式以及单一入口

这并不是一个控制器的基本组成部分，而是包含了model和view的一个控制器例子，

首先注意控制器的类名应该是首字母大写的，然后在类的构造函数里应该调用父类的构造函数，之后则是func（）方法，也就是url后面所带参数的第二个部分，这个方法带有两个参数，这两个参数的值就是url的第三部分和第四部分的值，也就是单一入口的访问方式实际是：http：\\localhost\index.php\控制器名\方法名\方法的参数1\方法的参数2\。

 

在控制器类中每个方法代表一个页面，也就是可以将很多类似的操作放到一个控制器中，实现对操作的统一

在上述的例子中的func（）方法中的其他部分分别加载了model和view，加载model的时候加载的是在models文件夹中的msomemodel.php文件中的MSomemodel类，这个类负责应用程序的模型部分，也就是负责数据的交换，例如数据库的存储。

 

然后我们通过$data= $this-》MSomemodel-》getvalue（）执行了model中的一个方法，并从这个方法返回了数据，然后赋值给$data［‘data1’］，$data是一个关联数组，我们通过这个数组向view视图文件传值，而不是使用常见的模板模式，这种方法更好地分离了mvc各个部分的处理，同时在性能方面有其独特的一面。

之后我们通过将$data数组传给views文件夹中的welcome.php文件，这个文件是常规的php和html混写的脚本，在这个脚本中可以利用传过来的$data数组输出信息，但是注意在view文件中输出信息的时候不必使用$data［‘data1’］，而只需要echo $data1;即可。

基本的工作方式就是这样的，下面从代码级别来分析实现

代码分析

在CI中将Controller类作为超类来处理，也就是所有加载mvc实现模式的进程都从Controller类开始，所以我们忽略CI在加载到这个类的时刻前面的执行过程，而直接从Controller类所在的文件开始分析。

Controller类所在的文件位于system/libraries/Controller.php文件中。

在这个类中首先加载了所有必须的基础类，包括：‘Config’，‘Input’， ‘Benchmark’， ‘URI’， ‘Output’， ‘Language’， ‘Router’类。之后加载Roader类并执行了它的 _ci_autoloader（）方法，这个类是mvc模式的核心，控制器中所有其他内容的加载都是通过它实现的，下面对其代码进行分析：

首先来看 _ci_autoloader（）方法，这个函数实现了自动加载某些类库或者类，如果在你的应用程序中总是要用到某些类，但是你又不确保在CI中是否已经自动加载了这些类的话，你可以在config/autoload.php文件中设定要自动加载的library或者helper或者plugin的数组。具体请参考手册。

首先看看CI是如何加载libraries的，这个方法允许你在你的控制器的任何地方（通常是构造函数里）使用$this-》load-》library（“name”）;来加载某个类，这个类可以是用户自定义的类也可以是系统的类库，用户自定义的类需要遵循CI的约定，具体信息见手册中的“创建你自己的类库 ”部分.library（）方法以一个字符串或者一个类库名称的数组作为第一个参数，之后的处理将遍历然后加载所有的类，你可以通过第二个参数向要加载的类的构造函数传递参数，第三个参数允许你定义返回的对象的名称，后面的两个参数通常不使用，这个方法在简单判断了参数是否为空之后调用了方法_ci_load_class（$class， $params = NULL， $object_name = NULL），这是一个非常复杂的函数，这个类加载第一个参数所指定的类，在这个类中进行了复杂的路径判断之后找到了所需要的类文件之后，调用了方法_ci_init_class（$class， ‘’， $params， $object_name）;这个类用来实例化一个类，如果在加载这个类的语句中包含了上述的第三个参数，则返回一个实例，以这个参数作为实例名，如果没有设置第三个参数，则返回一个以类名命名的实例名，这也是为什么前面的例子中在加载了model之后，直接将model类名作为一个对象使用的原因。

之后我们来看CI是如何加载模型的，这个方法允许你在控制器中使用$this-》load-》model（$modelname，$name，$db_conn）加载模型，这三个参数分别是加载的模型的名称，加载后实例化的对象名称，是否自动连接数据库。后面两个参数可以省略，你可以讲多个模型一次载入，只需要将第一个参数设置成数组即可，这个方法首先将传过来的第一个参数以“\”分解成数组，这种机制允许你在模型中创建多层文件夹，更加合理地安排代码的分组，之后程序取出数组的最后一个元素作为要加载的类的名称，并根据路径寻找此类，之后包含此文件，并实例化此类，如果设置了第二个参数，则实例化到$name的对象中，否则默认以类名作为对象名进行实例化。

再来看CI是如何加载视图的，view（$view， $vars = array（）， $return = FALSE）方法的第一个参数是要加载的视图名称，第二个参数是要传给视图的变量值，第三个参数指定是否返回输出缓冲区的数据。这个方法将所有数组作为一个数组参数调用了_ci_load（$_ci_data）方法，这个方法将传过来的变量数组通过extract（）函数解析成符号表（也就是将键名当作变量名，值作为变量的值），并将这些变量缓存起来，以便可以再不同的视图中能够互相交流变量，也就是这个方法允许调用多次，为了在每次调用时都能自动加载已经传给前面视图的变量，将所有传给视图的变量都缓存在类的一个属性中，这样每次调用方法的时候都会获取所有的变量。之后加载这个视图文件，然后将其作为输出缓冲的一部分赋给全局变量$OUT，这个变量用来控制缓冲输出，这样做可以提高效率以及可以使调试的时间更准确。

其他的加载方法和上述的方法原理基本相同，只是根据情况有少许改变，CI在实现mvc模式的方法中将所有的文件都包含在控制器中，我们在包含了这些文件后，可以再控制器中自由使用这些对象和数据，然后最后通过缓冲输出类来输出所有的数据，虽然Loader这个类的结构看起来很复杂，但是其实它的实现时很简单的，其内部的代码原理基本相同，而且清晰明了，仔细看的话不难理解。
